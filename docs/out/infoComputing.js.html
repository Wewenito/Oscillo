<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>infoComputing.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Autoset.html">Autoset</a><ul class='methods'><li data-type='method'><a href="module-Autoset.html#.autoset">autoset</a></li><li data-type='method'><a href="module-Autoset.html#.updateCursorPosition">updateCursorPosition</a></li></ul></li><li><a href="module-Computing.html">Computing</a><ul class='methods'><li data-type='method'><a href="module-Computing.html#.calculateAutoMeasures">calculateAutoMeasures</a></li><li data-type='method'><a href="module-Computing.html#.calculateZoomFactors">calculateZoomFactors</a></li><li data-type='method'><a href="module-Computing.html#.generatePoints">generatePoints</a></li><li data-type='method'><a href="module-Computing.html#.getMilliVoltForACursor">getMilliVoltForACursor</a></li><li data-type='method'><a href="module-Computing.html#.getMilliVoltsPerDiv">getMilliVoltsPerDiv</a></li><li data-type='method'><a href="module-Computing.html#.getMilliVoltsRelativeToTriggerCursor">getMilliVoltsRelativeToTriggerCursor</a></li><li data-type='method'><a href="module-Computing.html#.getMillivoltsBetweenCursors">getMillivoltsBetweenCursors</a></li><li data-type='method'><a href="module-Computing.html#.getPositionRelativeToTriggerCursor">getPositionRelativeToTriggerCursor</a></li><li data-type='method'><a href="module-Computing.html#.getTimeBetweenCursors">getTimeBetweenCursors</a></li><li data-type='method'><a href="module-Computing.html#.getTimeForACursor">getTimeForACursor</a></li><li data-type='method'><a href="module-Computing.html#.getTimePerDiv">getTimePerDiv</a></li><li data-type='method'><a href="module-Computing.html#.getTimeScale">getTimeScale</a></li><li data-type='method'><a href="module-Computing.html#.mapRawToVoltage">mapRawToVoltage</a></li><li data-type='method'><a href="module-Computing.html#.mapVoltageToRaw">mapVoltageToRaw</a></li><li data-type='method'><a href="module-Computing.html#.resetMeasurements">resetMeasurements</a></li><li data-type='method'><a href="module-Computing.html#.setScreenInformation">setScreenInformation</a></li><li data-type='method'><a href="module-Computing.html#.toggleMeasurement">toggleMeasurement</a></li><li data-type='method'><a href="module-Computing.html#.updateGeneratedMathSignalsData">updateGeneratedMathSignalsData</a></li><li data-type='method'><a href="module-Computing.html#.updateTriggerSettings">updateTriggerSettings</a></li></ul></li><li><a href="module-Drawings.html">Drawings</a><ul class='methods'><li data-type='method'><a href="module-Drawings.html#.clearCanvas">clearCanvas</a></li><li data-type='method'><a href="module-Drawings.html#.drawCursors">drawCursors</a></li><li data-type='method'><a href="module-Drawings.html#.drawFFT">drawFFT</a></li><li data-type='method'><a href="module-Drawings.html#.drawGrid">drawGrid</a></li><li data-type='method'><a href="module-Drawings.html#.drawSignal">drawSignal</a></li><li data-type='method'><a href="module-Drawings.html#.drawTriggerCursor">drawTriggerCursor</a></li><li data-type='method'><a href="module-Drawings.html#.drawZoomRectangle">drawZoomRectangle</a></li><li data-type='method'><a href="module-Drawings.html#.removeSpikes">removeSpikes</a></li><li data-type='method'><a href="module-Drawings.html#.resetZoom">resetZoom</a></li></ul></li><li><a href="module-Exports.html">Exports</a><ul class='methods'><li data-type='method'><a href="module-Exports.html#.copyCanvasToClipboard">copyCanvasToClipboard</a></li><li data-type='method'><a href="module-Exports.html#.downloadCanvasAsImage">downloadCanvasAsImage</a></li><li data-type='method'><a href="module-Exports.html#.downloadDataToCsv">downloadDataToCsv</a></li></ul></li><li><a href="module-Main.html">Main</a><ul class='methods'><li data-type='method'><a href="module-Main.html#.MAINLOOP">MAINLOOP</a></li><li data-type='method'><a href="module-Main.html#.environmentSetup">environmentSetup</a></li><li data-type='method'><a href="module-Main.html#.fetchDataFromFile">fetchDataFromFile</a></li><li data-type='method'><a href="module-Main.html#.fetchRawData">fetchRawData</a></li><li data-type='method'><a href="module-Main.html#.getCurrentSettings">getCurrentSettings</a></li><li data-type='method'><a href="module-Main.html#.saveColorChoices">saveColorChoices</a></li></ul></li><li><a href="module-Misc.html">Misc</a><ul class='methods'><li data-type='method'><a href="module-Misc.html#.formatFrequency">formatFrequency</a></li><li data-type='method'><a href="module-Misc.html#.getMedian">getMedian</a></li><li data-type='method'><a href="module-Misc.html#.showToast">showToast</a></li></ul></li><li><a href="module-Trigger.html">Trigger</a><ul class='methods'><li data-type='method'><a href="module-Trigger.html#.getHundredItemsBeforeAfter">getHundredItemsBeforeAfter</a></li><li data-type='method'><a href="module-Trigger.html#.triggerCheck">triggerCheck</a></li></ul></li><li><a href="module-UI.html">UI</a><ul class='methods'><li data-type='method'><a href="module-UI.html#.changeChannelButtonStatus">changeChannelButtonStatus</a></li><li data-type='method'><a href="module-UI.html#.changeScreenLightMode">changeScreenLightMode</a></li><li data-type='method'><a href="module-UI.html#.changeScreenSize">changeScreenSize</a></li><li data-type='method'><a href="module-UI.html#.onMouseMoveScrollerHorizontal">onMouseMoveScrollerHorizontal</a></li><li data-type='method'><a href="module-UI.html#.onMouseMoveScrollerVertical">onMouseMoveScrollerVertical</a></li><li data-type='method'><a href="module-UI.html#.onMouseUpScrollerHorizontal">onMouseUpScrollerHorizontal</a></li><li data-type='method'><a href="module-UI.html#.onMouseUpScrollerVertical">onMouseUpScrollerVertical</a></li><li data-type='method'><a href="module-UI.html#.setScrollersEvents">setScrollersEvents</a></li><li data-type='method'><a href="module-UI.html#.setupDragListeners">setupDragListeners</a></li><li data-type='method'><a href="module-UI.html#.setupDragListeners">setupDragListeners</a></li><li data-type='method'><a href="module-UI.html#.setupTriggerCursor">setupTriggerCursor</a></li><li data-type='method'><a href="module-UI.html#.toggleDisplayForHorizontalCursorScrollers">toggleDisplayForHorizontalCursorScrollers</a></li><li data-type='method'><a href="module-UI.html#.toggleDisplayForVerticalCursorScrollers">toggleDisplayForVerticalCursorScrollers</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="VARIABLES.html">VARIABLES</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">infoComputing.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file infoComputing.js
 * @description This file contains every fonction needed to compute a result to display on-screen as numbers or as signals, etc.
 * 
 * Functions included in this file : 
 *  - **getTimeScale**
 *  - **getTimePerDiv**
 *  - **mapVoltageToRaw**
 *  - **mapRawToVoltage**
 *  - **getTimeBetweenCursors**
 *  - **getMillivoltsBetweenCursors**
 *  - **getMilliVoltForACursor**
 *  - **getMilliVoltsRelativeToTriggerCursor**
 *  - **getTimeForACursor**
 *  - **setScreenInformation**
 *  - **generatePoints**
 *  - **calculateAutoMeasures**
 *  - **getMilliVoltsPerDiv**
 *  - **updateGeneratedMathSignalsData**
 *  - **toggleMeasurement**
 *  - **resetMeasurements**
 *  - **getPositionRelativeToTriggerCursor**
 *  - **updateTriggerSettings**
 *  - **calculateZoomFactors**
 * 
 * @version 1.0.0
 * @since 2024-05-31
 * @author Owen Pichot
 * 
 * @license Public Domain
 */

/**
 * @module Computing
 */

/**
 * This function takes a time in seconds and scales it to something that makes more sense depending on the value.
 * 
 * @function getTimeScale
 * @memberof module:Computing
 * @param {number} timeInSeconds Time period in seconds. 
 * @returns {object} An object with two attributes, 'value' &amp; 'scale'.
 * @example
 * getTimeScale(0.05);
 * //output : { value: 50, scale: "ms" }
 * getTimeScale(0.0004);
 * //output : { value: 400, scale: "µs" }
 * getTimeScale(0.00000154);
 * //output : { value: 1.54, scale: "µs" }
 */
function getTimeScale(timeInSeconds){
    let scale;
    let value;

    //convert timeInSeconds to ms as a base unit to simplify the logic of the function
    const microseconds = timeInSeconds * 1e6;

    if (microseconds &lt; 1) {// nanoseconds
        scale = 'ns'; 
        value = (microseconds * 1000).toFixed(2); // convert to nanoseconds
    } else if (microseconds &lt; 1000) {// microseconds
        scale = 'µs'; 
        value = microseconds.toFixed(2);
    } else if (microseconds &lt; 1e6) {// Milliseconds
        scale = 'ms'; 
        value = (microseconds / 1000).toFixed(2); // convert microseconds to milliseconds
    } else { // Seconds
        scale = 's';
        value = (microseconds / 1e6).toFixed(2); // convert microseconds to seconds
    }

    return { value: parseFloat(value), scale: scale };
};

/**
 * This function returns how much time represents 1 horizontal division on screen.
 * 
 * @function getTimePerDiv
 * @memberof module:Computing
 * @returns {object} An object with two attributes, 'value' &amp; 'scale'.
 */
function getTimePerDiv() { 
    const totalSamplingTime = config.samplesPerFrame * 1e-8;
    const timePerDivision = (totalSamplingTime / config.horizontalDivisions) * (horizontalScale / 50);
    //we have to divide by 50 because the default value of the input is 50 which corresponds to 1 : no scaling
    
    const resultScaled = getTimeScale(timePerDivision);
    return resultScaled;
};

/**
 * This function converts a voltage to the equivalent absolute raw value of a 14-bit ADC
 * @function mapVoltageToRaw
 * @memberof module:Computing
 * @param {number} voltage - Voltage to convert.
 * @returns {number} The corresponding raw value to the voltage given.
 */
function mapVoltageToRaw(voltage) {
    return (voltage + (config.voltage / 2)) / config.voltage * config.maxSampleValue;
};

/**
 * This function converts a raw value from a 14-bit ADC to the equivalent voltage.
 * 
 * @function mapRawToVoltage
 * @memberof module:Computing
 * @param {number} rawValue - Raw value to convert.
 * @returns {number} The correponding voltage to the raw value given.
 */
function mapRawToVoltage(rawValue) {
    return (rawValue / config.maxSampleValue * config.voltage) - (config.voltage / 2);
}

/**
 * This function is used when the user uses the vertical measure cursors on the screen.
 * It calculates the time represented between the two vertical measure cursors.
 * @function getTimeBetweenCursors
 * @memberof module:Computing
 * @param {number} pixelsBetweenCursors Number of pixels between the two cursors.
 * @returns {number|string} Returns the time value and the corresponding scale.
 * @example
 * // /!\ Without any horizontal scaling /!\
 * getTimeBetweenCursors(542);
 * //output : { value: 4.63, scale: "µs" }
 * getTimeBetweenCursors(247):
 * //output : { value: 2.11, scale: "µs" }
 */
function getTimeBetweenCursors(pixelsBetweenCursors){
    const totalSamplingTime = config.samplesPerFrame * 1e-8;
    const sizeOfOneDivisionInPixels = CANVAS.width / config.horizontalDivisions;
    const DivisionsBetweenCursors = pixelsBetweenCursors / sizeOfOneDivisionInPixels;
    
    const TimeBetweenCursors = totalSamplingTime * (DivisionsBetweenCursors / config.horizontalDivisions) * (horizontalScale / 50);

    const resultScaled = getTimeScale(TimeBetweenCursors);
    return resultScaled;
};

/**
 * This function, similarly to 'getTimeBetweenCursors' gets the voltage represented between the two horizontal measure cursors.
 * It takes into account which channel we are currently focused on and its current vertical scaling.
 * 
 * @function getMillivoltsBetweenCursors
 * @memberof module:Computing
 * @param {number} pixelsBetweenCursors Number of pixels between the two cursors.
 * @returns {number|string} Returns the voltage and its associated scale (mv, v, etc).
 * @example
 * getMillivoltsBetweenCursors(254);
 * //output : { value: "698.5", scale: "mV" }
 * getMillivoltsBetweenCursors(57);
 * //output : { value: "156.8", scale: "mV" }
 */
function getMillivoltsBetweenCursors(pixelsBetweenCursors){
    //If a channel is focused then we get the mv/div of this one.
    let result = {value: "No channel", scale: "selected"};

    Object.keys(channelData).forEach(key => {
        if(channelData[key].focused){
            const sizeOfOneDivisionInPixels = CANVAS.height / config.verticalDivisions;
            const milliVoltsPerDivision = getMilliVoltsPerDiv(channelData[key].verticalScale);
            const milliVoltsBetweenCursors = (pixelsBetweenCursors / sizeOfOneDivisionInPixels) * milliVoltsPerDivision;
            result =  {value: milliVoltsBetweenCursors.toFixed(1), scale: "mV"};
        }
    });
    //If not, we just return "NA" until the user selects a certain channel. 
    return result;
};

/**
 * This function returns the equivalent in mV relative to the position of a horizontal measure cursor.
 * It also takes into account the vertical scaling of the current channel focused.
 * If no channel is focused then the function will just return "No channel Selected".
 * 
 * @function getMilliVoltForACursor
 * @memberof module:Computing
 * @param {number} cursorPosition Position, in pixels from the top of the screen to the cursor.
 * @returns {number|string} Returns the voltage (in mv) equivalent to the position of the cursor.
 * @example
 * getMilliVoltForACursor(150);
 * //output : { value: "687.5", scale: "mV" }
 * getMilliVoltForACursor(540);
 * //output : { value: -385, scale: "mV" }
 * getMilliVoltForACursor(300);//While no channel is focused.
 * //output : { value: "No channel", scale: "selected" }
 */
function getMilliVoltForACursor(cursorPosition){
    let result = {value: "No channel", scale: "selected"};

    Object.keys(channelData).forEach(key => {
        if(channelData[key].focused){
            const sizeOfOneDivisionInPixels = CANVAS.height / config.verticalDivisions;
            const milliVoltsPerDivision = getMilliVoltsPerDiv(channelData[key].verticalScale);
            if (cursorPosition == (CANVAS.height / 2)){
                result = {value: "0", scale: "mV"};
            }else if (cursorPosition > (CANVAS.height / 2)){//negative values
                const cursorValue = ((cursorPosition - (CANVAS.height / 2)) / sizeOfOneDivisionInPixels) * milliVoltsPerDivision;
                result = {value: -cursorValue.toFixed(1), scale: "mV"}
            }else if (cursorPosition &lt; (CANVAS.height / 2)){//positive values
                const cursorValue = (((CANVAS.height / 2) - cursorPosition) / sizeOfOneDivisionInPixels) * milliVoltsPerDivision;
                result = {value: cursorValue.toFixed(1), scale: "mV"}
            }
        }
    });
    return result;
};

/**
 * This fonction returns how much mV represents the current position of the trigger cursor (right of the screen, T icon).
 * This function is mostly used when the user moves the trigger cursor to change the current threshold.
 * 
 * @function getMilliVoltsRelativeToTriggerCursor
 * @memberof module:Computing
 * @param {number} Position Position of the trigger cursor, in pixels, on its scrollbar.
 * @returns {number|string} Returns the voltage (in mv) relative to the cursor's position.
 * @example
 * getMilliVoltsRelativeToTriggerCursor(150);
 * //output : { value: 687.5, scale: "mV" }
 * getMilliVoltsRelativeToTriggerCursor(430);
 * //output : { value: -82.5, scale: "mV" }
 */
function getMilliVoltsRelativeToTriggerCursor(Position){
    const triggerChannel = triggerOptions.triggerChannel;
    const sizeOfOneDivisionInPixels = CANVAS.height / config.verticalDivisions;
    const milliVoltsPerDivision = getMilliVoltsPerDiv(channelData[triggerChannel].verticalScale);
    let result;
    if (Position == (CANVAS.height / 2)){
        result = {value: "0", scale: "mV"};
    }else if (Position > (CANVAS.height / 2)){//negative values
        const cursorValue = ((Position - (CANVAS.height / 2)) / sizeOfOneDivisionInPixels) * milliVoltsPerDivision;
        result = {value: -cursorValue.toFixed(1), scale: "mV"}
    }else if (Position &lt; (CANVAS.height / 2)){//positive values
        const cursorValue = (((CANVAS.height / 2) - Position) / sizeOfOneDivisionInPixels) * milliVoltsPerDivision;
        result = {value: cursorValue.toFixed(1), scale: "mV"}
    }
    return result;
};

/**
 * Similarly to 'getMilliVoltForACursor', this function returns the equivalent time relative to the position of a vertical measure cursor.
 * It takes into account the global horizontal scaling of the oscilloscope.
 * 
 * @function getTimeForACursor
 * @memberof module:Computing
 * @param {number} cursorPosition Position, in pixels, from the left of the screen to the cursor.
 * @returns {number|string} Returns the time and time-scale relative to the cursor's position.
 * @example
 * getTimeForACursor(150);
 * //output : { value: 1.28, scale: "µs" }
 * getTimeForACursor(655);
 * //output : { value: 5.59, scale: "µs" }
 */
function getTimeForACursor(cursorPosition){
    const totalSamplingTime = config.samplesPerFrame * 1e-8; // Total time for all divisions.
    const sizeOfOneDivisionInPixels = CANVAS.width / config.horizontalDivisions; // Pixel width of one division.

    // Calculate how many divisions the cursor is from the left of the canvas.
    const divisionsFromLeft = cursorPosition / sizeOfOneDivisionInPixels;

    // Calculate the time at the cursor position using the proportion of the total time.
    const timeAtCursor = totalSamplingTime * (divisionsFromLeft / config.horizontalDivisions) * (horizontalScale / 50);

    const resultScaled = getTimeScale(timeAtCursor);
    return resultScaled;
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function setScreenInformation(){
    //insert time scale to the screen
    const timePerDiv = getTimePerDiv();
    document.getElementById('tpdiv-value').innerHTML = timePerDiv.value + ' ' + timePerDiv.scale + '/div';
    //console.log(`Time per division is : ${timePerDiv.value} ${timePerDiv.scale}`);

    Object.keys(channelData).forEach(key => {
        const voltsPerDiv = getMilliVoltsPerDiv(channelData[key].verticalScale);
        let channelNumber = parseInt(key.substring(2), 10);
        if (voltsPerDiv > 1000){
            document.getElementById('mes-CH' + channelNumber).innerHTML = (voltsPerDiv / 1000).toFixed(2) + ' V/dv';
        }else{
            document.getElementById('mes-CH' + channelNumber).innerHTML = voltsPerDiv + ' mv/dv';
        }
        document.getElementById('mes-CH' + channelNumber).style.color = channelData[key].colorDark;
    });

    if (triggerOptions.isTriggerOn == "on"){
        if (triggered){
            TRIGGER.style.color = "lightgreen"
        }else{
            TRIGGER.style.color = "chocolate"
        }
    }else{
        TRIGGER.style.color = "#e2e2e2"//white
    }

    //This section is about the auto-measures display.
    //These are put on screen below the voltages display.
    valuesToDisplay = []; // format inside : {text: "textToDisplay", color: "colorOfTheChannel", value: "valueToDisplay"}

    let min, max//we declare them here to reuse in case vpp and either min or max are set, it prevent another call to the function.
    
    
    if (autoMeasureOptions.vpp.set){// get min, max, vpp
        min = autoMeasures.getMinValue(channelData[autoMeasureOptions.associatedChannel].points);
        max = autoMeasures.getMaxValue(channelData[autoMeasureOptions.associatedChannel].points);
        let vpp = autoMeasures.getVppValue(channelData[autoMeasureOptions.associatedChannel].points);

        valuesToDisplay.push({
            text: "Vpp", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: vpp.toFixed(1) + "mV",
            id: "vpp-measure",
        });
    };

    if (autoMeasureOptions.min.set){// get only min
        if (min == undefined){
            min = autoMeasures.getMinValue(channelData[autoMeasureOptions.associatedChannel].points);
        }
        valuesToDisplay.push({
            text: "Min", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: min.toFixed(1) + "mV",
            id: "min-measure",
        });
    };

    if (autoMeasureOptions.max.set){// get only max
        if (max == undefined){
            max = autoMeasures.getMaxValue(channelData[autoMeasureOptions.associatedChannel].points);
        }
        valuesToDisplay.push({
            text: "Max", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: max.toFixed(1) + "mV",
            id: "max-measure",
        });
    };

    if (autoMeasureOptions.mean.set){// get avg value
        let mean = autoMeasures.getMeanValue(channelData[autoMeasureOptions.associatedChannel].points);
        valuesToDisplay.push({
            text: "Avg", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: mean.toFixed(1) + "mV",
            id: "avg-measure",
        });
    };

    if (autoMeasureOptions.mid.set){// get middle value
        let middle = autoMeasures.getMiddleValue(channelData[autoMeasureOptions.associatedChannel].points);
        valuesToDisplay.push({
            text: "Mid", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: middle.toFixed(1) + "mV",
            id: "mid-measure",
        });
    };

    if (autoMeasureOptions.rms.set){// get rms value
        let rms = autoMeasures.getRMS(channelData[autoMeasureOptions.associatedChannel].points);
        valuesToDisplay.push({
            text: "RMS", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: rms.toFixed(1) + "mV",
            id: "rms-measure",
        });
    };

    function formatFrequency(frequency) {
        if (frequency >= 1e9) {  // gte to 1 Gigahertz
            return (frequency / 1e9).toFixed(1) + " GHz";
        } else if (frequency >= 1e6) {  // gte to 1 Megahertz
            return (frequency / 1e6).toFixed(1) + " MHz";
        } else if (frequency >= 1e3) {  // gte to 1 Kilohertz
            return (frequency / 1e3).toFixed(1) + " kHz";
        } else {
            return frequency.toFixed(1) + " Hz";  // lt 1 Kilohertz, display in Hertz (Very very very unlikely but still, we never know)
        }
    }

    if (autoMeasureOptions.freq.set){// get avg frequency
        let freq = autoMeasures.getAverageFrequency(channelData[autoMeasureOptions.associatedChannel].points, config.frequency);
        valuesToDisplay.push({
            text: "Freq", 
            color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
            value: formatFrequency(freq),
            id: "avg-freq-measure",
        });
    };

    if (autoMeasureOptions.highFreq.set || autoMeasureOptions.lowFreq.set){// get min and max frequencies
        let freqs = autoMeasures.getFrequenciesMaxMin(channelData[autoMeasureOptions.associatedChannel].points, config.frequency);
        if (autoMeasureOptions.highFreq.set){// high freq
            valuesToDisplay.push({
                text: "Max Freq", 
                color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
                value: formatFrequency(freqs.highestFrequency),
                id: "max-freq-measure",
            });
        };

        if (autoMeasureOptions.lowFreq.set){//low freq
            valuesToDisplay.push({
                text: "Min Freq", 
                color: channelData[autoMeasureOptions.associatedChannel].colorDark, 
                value: formatFrequency(freqs.lowestFrequency),
                id: "min-freq-measure",
            });
        };
    };

    //now we inject the calculated values to the html page.
    const valuesContainer = document.getElementById('auto-measures-display');
    valuesContainer.querySelectorAll('p').forEach(p => p.style.display = 'none');
    for (let i = 0; i &lt; valuesToDisplay.length; i++) {
        let paragraph = document.getElementById(valuesToDisplay[i].id);
        paragraph.style.display = 'block';
        paragraph.style.color = valuesToDisplay[i].color;
        paragraph.style.borderColor = valuesToDisplay[i].color;
        paragraph.textContent = valuesToDisplay[i].text + " : " + valuesToDisplay[i].value;
    };
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function generatePoints(channelKey){
    const originChannel1 = channelData[channelKey].originChannel1;
    const originChannel2 = channelData[channelKey].originChannel2;
    const operation = channelData[channelKey].operation;

    if (operation == "squared"){
        const pointsSquared = channelData[originChannel1].points.map(point => {
            const voltage = autoMeasures.voltage_from_raw(point);
            const squaredVoltage = voltage * voltage;
            return parseInt(mapVoltageToRaw(squaredVoltage).toFixed(0));
        });

        channelData[channelKey].points = pointsSquared;
        return
    };

    if (operation == "deriv"){
        function getDerivative(points) {
            let derivative = [];
            for (let i = 0; i &lt; points.length - 1; i++) {
                difference = points[i + 1] - points[i];
                //Since the derivative show the difference between two points on the graph we need to add the equivalent of 1/2 the height of the graph 
                //so that it doesn't start being drawn at the bottom of the screen.
                derivative[i] = parseInt((difference + (config.maxSampleValue / 2)).toFixed(0));
            }
            return derivative;
        };
        
        channelData[channelKey].points = getDerivative(channelData[originChannel1].points);
        return
    }

    if (operation == "integral"){
    
        function integrateSignal(points, deltaT) {
            const integratedSignal = [];
            let integralSum = 0;
            for (let i = 0; i &lt; points.length; i++) {
                const pointV = mapRawToVoltage(points[i]);
                integralSum += pointV * deltaT;
                integratedSignal.push(mapVoltageToRaw(integralSum));
            }
            return integratedSignal;
        }
        channelData[channelKey].points = integrateSignal(channelData[originChannel1].points, 1);
        return
    };

    if (operation == "fft") {
        function fillArrayToNextPowerOfTwo(array) {
            // check if the length of the array is already a power of two
            function isPowerOfTwo(n) {
                return n &amp;&amp; (n &amp; (n - 1)) === 0;
            }
        
            let targetLength = array.length;
            if (!isPowerOfTwo(targetLength)) {
                // if not a power of two, find the next power of two
                targetLength = Math.pow(2, Math.ceil(Math.log2(targetLength)));
                // fill the array with zeros until it reaches the target length
                while (array.length &lt; targetLength) {
                    array.push(0);
                }
            }
        
            return array;
        }

        function calculateFFT(points, sampleRate) {
            //===============================================================
            // FFT calculation - credit : https://github.com/indutny/fft.js/
            //===============================================================
            const fft = new FFT(points.length);
        
            const complexInput = fft.toComplexArray(points);
            const complexOutput = fft.createComplexArray();
        
            fft.realTransform(complexOutput, complexInput);
            fft.completeSpectrum(complexOutput);
        
            const magnitudes = complexOutput.map((value, index) => {
                if (index % 2 === 0) {
                    // even index, real part
                    const re = value;
                    // odd index, imaginary part (since the array is [re, im, re, im, ...]) => see fft.js doc
                    const im = complexOutput[index + 1];
                    return Math.sqrt(re * re + im * im);
                }
                return null;
            })

            const displayData = magnitudes.map((magnitude, index) => {
                const frequency = index * sampleRate / points.length;
                return { frequency: frequency, magnitude: magnitude };
            });
        
            const halfDisplayData = displayData.slice(0, displayData.length / 2);
            return halfDisplayData;
        }
        //we have to fill the gaps in the array until the next power of 2 (required by the library)
        let tempOriginChannel = channelData[originChannel1];
        channelData[channelKey].points = fillArrayToNextPowerOfTwo(tempOriginChannel.points);
        channelData[channelKey].points = calculateFFT(channelData[channelKey].points, config.frequency);

        channelData[channelKey].verticalScale = 2.5; // We set the vertical scale to 2.5 to make the fft thinner than other signals. This can still be modified by the user oc.
        return
    };

    if (operation == "add"){
        const points1 = channelData[originChannel1].points;
        const points2 = channelData[originChannel2].points;
        const pointsAdded = points1.map((point, index) => {
            point = autoMeasures.voltage_from_raw(point);
            let point2 = autoMeasures.voltage_from_raw(points2[index]);
            return parseInt(mapVoltageToRaw(point + point2).toFixed(0));
        });
        channelData[channelKey].points = pointsAdded;
    };

    if (operation == "mult"){
        const points1 = channelData[originChannel1].points;
        const points2 = channelData[originChannel2].points;
        const pointsMultiplied = points1.map((point, index) => {
            point = autoMeasures.voltage_from_raw(point);
            let point2 = autoMeasures.voltage_from_raw(points2[index]);
            return parseInt(mapVoltageToRaw(point * point2).toFixed(0));
        });
        channelData[channelKey].points = pointsMultiplied;
    };

    if (operation == "sub"){
        const points1 = channelData[originChannel1].points;
        const points2 = channelData[originChannel2].points;
        const pointsSubtracted = points1.map((point, index) => {
            point = autoMeasures.voltage_from_raw(point);
            let point2 = autoMeasures.voltage_from_raw(points2[index]);
            return parseInt(mapVoltageToRaw(point - point2).toFixed(0));
        });
        channelData[channelKey].points = pointsSubtracted;
    };

    if (operation == "div"){
        const points1 = channelData[originChannel1].points;
        const points2 = channelData[originChannel2].points;
        const pointsDivided = points1.map((point, index) => {
            point = autoMeasures.voltage_from_raw(point);
            let point2 = autoMeasures.voltage_from_raw(points2[index]);
            if (point2 === 0){
                return 8192;// = 0V 
            }else{
                return parseInt(mapVoltageToRaw(point / point2).toFixed(0));
            }
        });
        channelData[channelKey].points = pointsDivided;
    };
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function calculateAutoMeasures(){
    //converts an absolute value (from 0 to 16383) to the corresponding voltage value (-1.1 to +1.1v or else if the config changes).
    function voltage_from_raw(raw_value, max_raw=config.maxSampleValue){
        let voltage_range = [-(config.voltage/2), config.voltage/2]
        let span = voltage_range[1] - voltage_range[0]
        normalized = raw_value / max_raw
        return voltage_range[0] + (normalized * span)
    };

    function getMinValue(points){
        let minAbsValue = Math.min(...points); // get smallest value from array
        minAbsValue = voltage_from_raw(minAbsValue); //convert abs value to V
        return minAbsValue * 1000;//convert V to mV
    }

    function getMaxValue(points){
        let maxAbsValue = Math.max(...points); // get biggest value from array
        maxAbsValue = voltage_from_raw(maxAbsValue); //convert abs value to V
        return maxAbsValue * 1000;//convert V to mV
    }

    function getVppValue(points){
        const maxVoltage = getMinValue(points);//mV
        const minVoltage = getMaxValue(points);//mV
        const vpp = maxVoltage - minVoltage;//mV
        return vpp;
    }

    function getMeanValue(points){
        const average = getMedian(points);//Get the average abs value of the array
        const averageInVolts = voltage_from_raw(average); //convert abs value to V
        return averageInVolts * 1000;//convert V to mV
    }

    function getMiddleValue(points){
        let middleAbs = Math.round(points.length / 2); //get the middle of the point array
        middleInVolts = voltage_from_raw(points[middleAbs]);//convert the value in volts
        return middleInVolts * 1000; //convert V to mV
    }

    function getRMS(points){
        let sum = 0;
        points.forEach(point => {//add each point squared to the total sum
            sum += point * point;
        });
        const rmsAbs = Math.sqrt(sum / points.length);//take the square root of the average of the points
        const rmsInVolts = voltage_from_raw(rmsAbs);//convert the value in volts
        return rmsInVolts * 1000;//convert final value to mV
    }

    function getAverageFrequency(points, sampleRate) {
        const threshold = calculateThreshold(points); // Define a suitable threshold
        let cycleCount = 0;
        let isInCycle = false;
    
        for (let i = 0; i &lt; points.length; i++) {
            if (points[i] > threshold &amp;&amp; !isInCycle) {
                cycleCount++;  // start of a new cycle
                isInCycle = true;
            } else if (points[i] &lt; threshold &amp;&amp; isInCycle) {
                isInCycle = false;  // end of a cycle
            }
        }
        const totalDuration = points.length / sampleRate;  // total duration in seconds (sample rate will be at 1e8 Hz since agata has a sampling period of 10ns)
        return cycleCount / totalDuration;  // average frequency in Hz
    }
    
    function calculateThreshold(points) {
        let mean = points.reduce((acc, val) => acc + val, 0) / points.length;
        let sumOfSquares = points.reduce((acc, val) => acc + (val - mean) ** 2, 0);
        let standardDeviation = Math.sqrt(sumOfSquares / points.length);
        return mean + standardDeviation;  // Threshold at mean + 1 SD
    }

    function getFrequenciesMaxMin(points, sampleRate) {
        const threshold = calculateThreshold(points);
        let cycleStart = null;
        let frequencies = [];
    
        for (let i = 0; i &lt; points.length; i++) {
            if (points[i] > threshold &amp;&amp; cycleStart === null) {
                cycleStart = i;  //new cycle
            } else if ((points[i] &lt; threshold || i === points.length - 1) &amp;&amp; cycleStart !== null) {
                const cycleEnd = i;
                const cycleDuration = (cycleEnd - cycleStart) / sampleRate;  // one cycle in seconds
                if (cycleDuration > 0) {  // avoid division by zero
                    const frequency = 1 / cycleDuration;
                    frequencies.push(frequency);
                }
                cycleStart = null;  // look for new cycle in the next loop
            }
        }
    
        if (frequencies.length === 0) {
            return {lowestFrequency: 0, highestFrequency: 0};  // no cycles found
        }
    
        const lowestFrequency = Math.min(...frequencies);
        const highestFrequency = Math.max(...frequencies);
    
        return {
            lowestFrequency: lowestFrequency,
            highestFrequency: highestFrequency
        };
    }

    return {getMinValue, getMaxValue, getVppValue, getMeanValue, getMiddleValue, getRMS, getAverageFrequency, getFrequenciesMaxMin, voltage_from_raw};
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function getMilliVoltsPerDiv(channelVerticalScale) {
    const totalVoltageRange = config.voltage; //voltage range we get from the settings (-V to +V)
    const verticalDivisions = config.verticalDivisions;

    const voltsPerDivision = totalVoltageRange / (verticalDivisions * channelVerticalScale); 

    return (voltsPerDivision * 1000).toFixed(1);
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function updateGeneratedMathSignalsData(slotChannel, channel1, channel2, operation){
    //console.log(`Updating math signal in slot ${slotChannel} for the operation : ${operation} between ${channel1} and ${channel2}`);

    channelData[slotChannel] = {
        points: [],
        display: true,
        type: "generatedData",
        focused: false,
        colorDark: channelsMetaData[slotChannel].colorDark,
        colorLight: channelsMetaData[slotChannel].colorLight,
        verticalOffset: 0,
        verticalScale: 1,
        verticalOffsetRelativeCursorPosition: 395,
        //these attributes are specific to generated signals from a function
        originChannel1: channel1,
        originChannel2: channel2,//none if operation does not require 2 channels
        operation: operation,
    };

    //Here we set the button styles to make it show up as available
    channelButton = document.getElementById(slotChannel);

    channelButton.classList.remove("channel-not-displayed");
    channelButton.classList.add("channel-displayed");
    channelButton.classList.add(channelData[slotChannel].colorDark);

    //we update the global config to reflect the new channel
    config.numChannels += 1;

    //we add a cursor for this newly created channel
    const scroller = document.getElementById("scroller-" + slotChannel);
    scroller.style.display = "block";
    scroller.style.backgroundColor = channelData[slotChannel].colorDark;
    const channelID = slotChannel.split("CH")[1];
    setScrollersEvents(channelID);
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function toggleMeasurement(measureKey, buttonId) {
    let measure = autoMeasureOptions[measureKey];
    if (measure) {
        measure.set = !measure.set; // Toggle the 'set' value
        //change button class depending on wether the measure is set or not
        document.getElementById(buttonId).className = measure.set ? 'modal-measure-button active-measure-button' : 'modal-measure-button inactive-measure-button';
        console.log(`${measureKey} set to ${measure.set}`);
    }
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function resetMeasurements(){
    try{
        autoMeasureOptions.associatedChannel = "CH1";
        Object.keys(autoMeasureOptions).forEach(key => {
            if (key !== "associatedChannel") {
                autoMeasureOptions[key].set = false;
                autoMeasureOptions[key].value = null;
                document.querySelectorAll('.modal-measure-button').forEach(button => {
                    button.className = 'modal-measure-button inactive-measure-button';
                });
            }
        });
        document.getElementById("selectChannel").value = "CH1";
    
        showToast("Auto Measurements values reset !", "toast-info");
    } catch (error) {
        console.error('Failed to reset measurements', error);
        showToast("Error while resetting the measurements..", "toast-error");
    }
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function getPositionRelativeToTriggerCursor(milliVolts, channelKey) {
    const sizeOfOneDivisionInPixels = CANVAS.height / config.verticalDivisions;
    const milliVoltsPerDivision = getMilliVoltsPerDiv(channelData[channelKey].verticalScale);
    let position;
    if (milliVolts === 0) {
        position = CANVAS.height / 2;
    } else if (milliVolts &lt; 0) {
        const cursorValue = Math.abs(milliVolts) / milliVoltsPerDivision;
        position = (CANVAS.height / 2) + (cursorValue * sizeOfOneDivisionInPixels);
    } else if (milliVolts > 0) {
        const cursorValue = milliVolts / milliVoltsPerDivision;
        position = (CANVAS.height / 2) - (cursorValue * sizeOfOneDivisionInPixels);
    }

    return position;
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function updateTriggerSettings(modalElement){
    triggerOptions.isTriggerOn = modalElement.querySelector("#selectOnOffStatus").value;
    triggerOptions.triggerMode = modalElement.querySelector("#selectTriggerMode").value;
    triggerOptions.triggerChannel = modalElement.querySelector("#selectTriggerChannel").value;
    if (modalElement.querySelector("#TriggerLevelInput").value > 1100){
        triggerOptions.triggerLevel = 1100
    }else if(modalElement.querySelector("#TriggerLevelInput").value &lt; -1100){
        triggerOptions.triggerLevel = -1100
    }else{
        triggerOptions.triggerLevel = modalElement.querySelector("#TriggerLevelInput").value;
    }
    if (modalElement.querySelector("#WindowLevelMinInput").value > 1100){
        triggerOptions.windowLevelMin = 1100
    }else if(modalElement.querySelector("#WindowLevelMinInput").value &lt; -1100){
        triggerOptions.windowLevelMin = -1100
    }else{
        triggerOptions.windowLevelMin = modalElement.querySelector("#WindowLevelMinInput").value;
    }
    if (modalElement.querySelector("#WindowLevelMaxInput").value > 1100){
        triggerOptions.windowLevelMax = 1100
    }else if(modalElement.querySelector("#WindowLevelMaxInput").value &lt; -1100){
        triggerOptions.windowLevelMax = -1100
    }else{
        triggerOptions.windowLevelMax = modalElement.querySelector("#WindowLevelMaxInput").value;
    }
    triggerOptions.triggerSlope = modalElement.querySelector("#selectTriggerSlope").value;
    if (modalElement.querySelector("#holdOffInput").value > 3600){
        triggerOptions.holdOff = 3600
    }else if(modalElement.querySelector("#holdOffInput").value &lt; 0){
        triggerOptions.holdOff = 0
    }else{
        triggerOptions.holdOff = modalElement.querySelector("#holdOffInput").value;
    }

    showToast("Trigger settings updated !", "toast-info");

    if (triggerOptions.isTriggerOn == "on"){
        document.getElementById("trigger-cursor").style.display = "block";

        const newCursorPosition = getPositionRelativeToTriggerCursor(parseFloat(triggerOptions.triggerLevel), triggerOptions.triggerChannel);
        document.getElementById("trigger-cursor").style.top = newCursorPosition + 'px';
    }else{
        document.getElementById("trigger-cursor").style.display = "none";
    }
};

/**
 * 
 * @function
 * @memberof module:Computing
 * @returns {type} Desc
 */
function calculateZoomFactors() {
    const selectedWidth = zoomConfig.finalX - zoomConfig.initX;
    const selectedHeight = zoomConfig.finalY - zoomConfig.initY;

    // Calculate scale factors to fit the selected area to the canvas size
    zoomConfig.zoomX = CANVAS.width / selectedWidth;
    zoomConfig.zoomY = CANVAS.height / selectedHeight;
};</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Thu May 23 2024 13:36:20 GMT+0100 (Western European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
